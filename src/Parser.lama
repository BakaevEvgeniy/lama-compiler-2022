-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [s (op), fun (l, op, r) { Binop (op, l, r) }]
}

-- Primary expression
var primary = memo $ eta syntax (
  x=decimal { Const (stringInt (x)) } |
  x=lident { Var (x) }                |
  inbr[s ("("), exp, s (")")]
),
    binOps = fun(l, op, r) {Binop(op, l, r)},
    ops = {
      [Left, [s ("!!"), binOps] : {}],
      [Left, [s ("&&"), binOps] : {}],
      [Nona, [s ("<") | s (">") | s ("<=") | s (">=") | s ("==") | s ("!="), binOps] : {}],
      [Left, [s ("+") | s ("-"), binOps] : {}],
      [Left, [s ("*") | s ("/") | s ("%"), binOps] : {}]},
    exp = memo $ eta expr (ops, primary) ;

var elseHelper = memo $ eta syntax (
  kElif e=exp kThen s1=stmts s2=elseHelper {If (e, s1, s2)} |
  kElse s=stmts kFi {s}                                   |
  kFi {Skip}
);


var stmt = memo $ eta syntax (
  kSkip {Skip} |
  x=lident s[":="] e=exp {Assn (x, e)} | 
  kRead x=inbr[s ("("), lident, s (")")] {Read (x)} | 
  kWrite e=inbr[s ("("), exp, s (")")] {Write (e)} | 
  kIf e=exp kThen st=stmts el=elseHelper {If (e, st, el)} | 
  kWhile e=exp kDo st=stmts kOd {While (e, st)} | 
  kDo st=stmts kWhile e=exp kOd {DoWhile (st, e)} | 
  kFor begin=stmts s[","] e=exp s[","] inc=stmts kDo body=stmts kOd {Seq (begin, While (e, Seq (body, inc)))}
), stmts = memo $ eta syntax ( stmt | 
                                stmt1=stmt s[";"] stmt2=stmts {Seq (stmt1, stmt2)});
-- Public top-level parser
public parse = stmts;
